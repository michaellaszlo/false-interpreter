
--------
Existing visual interpreters:

  http://morphett.info/false/false.html

  http://www.quirkster.com/iano/js/false-js.html


--------
Scanning

We check for four syntax errors while scanning:
- single quote not followed by a character (i.e., single quote ends program)
- opening double quote not followed by closing double quote (i.e., odd number)
- left brace not followed by right brace (we ignore left braces in between)
- a character that does not correspond to any operator or value


--------
Parsing

We're working with four kinds of tokens: value, variable, operator, delimiter
- tokens of the first three kinds are terms in a linear sequence
- the only recursive construct is open lambda ... close lambda
  (we discarded the string delimiters in the scanning phase)

What is a lambda function?
- it is a program within a program, and is executed like a top-level program
- when we execute a lambda function, its elements are evaluated one by one
- for any expression E, evaluating E is equivalent to evaluating F = [ E ] !
- therefore, let us consider the top-level program to be a lambda function
- given a program P, we construct the parse tree [ P ] and evaluate [ P ] !

The root of the parse tree is a lambda node.
- its children are a sequence of { value, operator, variable, lambda } nodes

We could do some type-checking in the parsing phase. For example:
- an integer must not be followed by a variable operator
- a variable name must not be followed by an arithmetic operator
But many other type mismatches can occur at runtime.
- we can't predict the result of a variable lookup or lambda application
We'll leave all type-checking to the evaluation phase.



--------
Types

The FALSE specification provides for integers and characters: """
  values are either integers like discussed before ("1", "100" etc.),
  or characters precede by a quote: 'A (equals 65)
"""
- there are also strings, but there are no string operations
- a string just prints itself
- output: "." prints a value as an integer and "," as a character
- strings print themselves
- boolean values are implied: """
  "=" ">"
  these result in 0 (false) or -1 (true)
"""
- there is no special output for boolean values
- the integer-boolean conversion is unspecified
- we presume that all values other than 0 are understood to mean true

We can introduce a boolean type while supporting previously written programs.
- integer <-> character coercion is already implied
- we'll make the character type explicit
- we'll also have a boolean type, with conversion to and from the other types
- logical operators coerce their operands to boolean values
- arithmetic operators coerce their operands to integer values
- let's add an output operator that prints boolean values


--------
I/O model

Three displays: output, input, console.
- output operations print to the output buffer
- input operations read from the input buffer
- a button allows the user to insert an EOF character into the input buffer

What does the flush operation do?
- first it prints the contents of the output buffer to the console
- then it prints the scanned portion of the input buffer to the console
- the unread portion of the input buffer remains in the input buffer

Newline characters ('\n') are replaced with line breaks (<br>).
- no other substitutions are made.
- the editor allows no invisible characters except space and newline
- one writes a newline by typing a real newline, not an escaped code
- attempts to write '\t', '\n', and so on will result in literal text
- it is not possible to make an EOF character in source code

